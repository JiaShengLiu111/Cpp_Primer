**引用类型的形参**：是其对应的实参的别名。

**指针形参**：和普通“传值参数”类似，指针的值被拷贝给形参。拷贝之后，实参指针和形参指针不是同一个指针，但是它们指向同一个对象。局部函数可以修改实参指针所指对象的值，但是却无法修改实参本身。

> 使用引用避免拷贝

当某些对象特别大时，直接拷贝给形参是十分低效的操作。特别是当函数中不会修改实参的值时，直接使用引用作为实参是最好的选择。另外，为了确保函数内部确实不会修改对象的值，可以将引用形参定义为const类型。另外，还可以利用引用形参使得一个函数返回额外的信息（即，可以在函数内部修改引用形参，作为额外信息）。

**注意**：为const类型的引用形参传入非const类型的实参是合法的，编译器不会通过引用形参修改实参的值。



> 备注

1.void fun(const int i)和void fun(int i)被认为是重复定义，虽然两个函数形参形式上有区别，但在比较两个函数定义是否重复时，顶层的const会被忽略掉。

**解释**：对于函数void fun(const int i)既可以传入const实参，也可以传入非const实参。因此，当向fun中传入一个非const实参时，编译器无法判断应该调用哪一个函数。所以认为这两个函数属于重复定义。

**注意**：仅仅是顶层const会被忽略；底层const仍然会被保留。例如：void fun(const int * i)和void fun(int * i)，不认为是重复的函数定义。**原因还不太明白？？？？？**

经过实验，int *类型的实参同样可以传递给const int *  类型的形参。使用int *i形参时，编译器对于void fun(int * i)函数的调用优先级高于void fun(const int * i)函数。