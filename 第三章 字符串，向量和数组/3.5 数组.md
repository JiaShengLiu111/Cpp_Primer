### 3.5.5 定义和初始化内置数组

#### 理解复杂的数组申明

int *ptrs[10]：首地址为ptrs，且长度为十的数组，数组的每个元素都是一个指向int类型的指针。

int (*ptrs)[10]：ptrs指向一个长度为十的整型数组。



int &ptrs[10] = **&arr**：错误，不存在引用数组。

int (&ptrs)[10] = **arr**：ptrs表示对一个长度为十整型数组的引用。



> 总结：

对于一个数组的定义，[]前的内容是否被括号所括住，解释通常具有很大的区别。例如：

**int (*ptrs)[10]**：[]前的内容被括号所括住，所以 *ptrs就表示数组的首地址，数组的类型为int。既然 *ptrs表示数组的首地址，因此ptrs就表示指向数组的指针。

**int *ptrs[10]**：[]前的内容没有被括号所括住，所以ptrs就表示数组的首地址，数组的类型为int*。

同理，

**int (&arrRef)[10] = arr**：[]前的内容被括号所括住，所以 &ptrs就表示数组的首地址，数组的类型为int。&表示ptrs是对某个变量的引用，所以ptrs是对某个长度为10的整型数组首地址（arr）的引用。

**int &refs[10]**：[]前的内容没有被括号所括住，所以ptrs就表示数组的首地址，数组的类型为int&。由于不存在引用类型的数组，所以这个定义是有错误的。



> 为什么不存在引用类型的数组？

数组，使用的是连续的内存空间来存储数据，假如存在某个数组存储的数据的类型是int&，则数组中每个元素都是对分布在内存不同位置的int类型数据的引用，这显然和“数组使用连续的内存空间来存储数据”相互矛盾。总而言之，数据的类型之所以不能是引用类型，是因为不能保证数据所引用的元素位于连续的内存空间中。

那么，假如存在一系列的int类型的数据，位于连续的内存空间中，想被某个引用类型的数组的每个元素依次引用，是否行得通？

答案是肯定的，其实它的本质就是**对数组的引用**。然而对数组的引用不需要依次对数组中每个元素进行引用，只需要对数组的首地址进行引用即可，如上述使用示例：

![1535165444500](./assets/1535165444500.png)



当然，对复杂的数组声明中，对修饰符的数据并没有限制，例如：

int *(&arrRef) [10] = arr;  // 如上分析，该数组的首地址为&arrRef，数组的类型为int *，又由&符号可知，arrRef是对某个变量的引用。最终可以分析出：arrRef是对某个长度为10的int *类型数组首地址的引用。







